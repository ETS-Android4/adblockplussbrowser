# So far release process is:
# - build a release apk from dev branch
# - mark it with the release tag /^release-\d+\.\d+\.\d+(-rc[0-9])?$/
# - upload it to `internal` release track (WIP)
# - promote it to release
#
# Since we release straight from the `dev` branch, there is no need for a special build release job
# but we may consider additional round of testing against release tag in the future
# (/^release-\d+\.\d+\.\d+(-rc[0-9])?$/) regex can be used for filtering

stages:
  - build:debug
  - build:internal
  - sign_builds
  - device_tests

image: gradle:jdk8

variables:
  # only `worldAbp` flavor is considered for now
  APK_OUTPUT_PATH: "app/build/outputs/apk/worldAbp"
  APK_DEBUG_PATH: "$APK_OUTPUT_PATH/debug/app-world-abp-debug.apk"
  APK_RELEASE_UNSIGNED_PATH: "$APK_OUTPUT_PATH/release/app-world-abp-release-unsigned.apk"
  APK_RELEASE_SIGNED_PATH: "$APK_OUTPUT_PATH/release/app-world-abp-release-unsigned.apk"

# we would need a template for other type of builds
.template_build:
  variables:
    GRADLE_OPTS: "-Dorg.gradle.daemon=false"
    ANDROID_SDK_TOOLS: "4333796"

  before_script:
    - export GRADLE_USER_HOME=`pwd`/.gradle
    - apt-get --quiet update --yes
    - apt-get --quiet install --yes wget tar unzip lib32stdc++6 lib32z1
    - wget --quiet --output-document=android-sdk.zip https://dl.google.com/android/repository/sdk-tools-linux-${ANDROID_SDK_TOOLS}.zip
    - unzip -q -d android-sdk-linux android-sdk.zip && rm android-sdk.zip
    - export ANDROID_HOME=$PWD/android-sdk-linux
    # temporarily disable checking for EPIPE error and use yes to accept all licenses
    - set +o pipefail
    - yes | android-sdk-linux/tools/bin/sdkmanager --licenses >/dev/null
    - set -o pipefail
    - cat "$GOOGLE_SERVICES" > "$(pwd)/app/google-services.json"
  cache:
    key: debug-keystore
    paths:
      - $HOME/.android

build:
  extends: .template_build
  stage: build:debug
  script:
    - ./gradlew --build-cache assembleWorldAbpDebug
  artifacts:
    expire_in: 2 month
    paths:
      - $APK_DEBUG_PATH

# A job for doing nightly builds against `dev` branch
#
# It supposed to catch build errors along with running extensive long-running tests
# and later publishing to internal track (WIP)
# This is not a scheduled job, because a scheduled job does not know how to run only when
# the branch has changed. Therefore we just delay a run for 8 hours (a working day)
nightly:
  extends: .template_build
  stage: build:internal
  only:
    refs:
      - dev
      - web
  script:
    # we build both debug & release because we'd like to catch build errors for production
    # and have a release signed apk for publishing it to internal track later (WIP)
    - ./gradlew assembleWorldAbp
  artifacts:
    expire_in: 6 month
    paths:
      - $APK_DEBUG_PATH
      - $APK_RELEASE_PATH
  # there is no way of scheduling a job and running it only if source code has changed
  # so, we are just delaying the job execution to 8 hours with assumption that when there is a new
  # commit in `dev` branch, it happened during the working hours and +8 hours mean out of working
  # hours hence the CI would be free from doing merge request builds
  when: delayed
  start_in: 8 hours

# sign an apk with an external shared apk signing server
# apk signing server is shared so we'd like to sign only release builds
# we are not using regular apk signing because we do not have control over the app keys
sign_apks:
  stage: sign_builds
  only:
    variables:
      - $FORCE_NIGHTLY == "true"
    refs:
      - dev
      - web
  variables:
    GIT_STRATEGY: none
  tags:
    # this tag indicates a signing server hidden somewhere inside the company infrastructure
    - "apk_signer_apk-signing-1.uplink.eyeo.it"
  before_script:
    - "rm -fr ./*_SIGNED.apk"
  script:
    - |
      for UNSIGNED_FILE in $(find app/build/outputs/apk -name "*-unsigned.apk")
        do
        SIGNED_FILE=$(basename "${UNSIGNED_FILE/-unsigned.apk/_SIGNED.apk}")
        echo "Signing ${UNSIGNED_FILE} to ${SIGNED_FILE}"
        /usr/local/bin/apk_signer < $UNSIGNED_FILE > $SIGNED_FILE
      done
    - ls -1 ./*_SIGNED.apk
    - mv ./*_SIGNED.apk app/build/outputs/apk/worldAbp/release/
  artifacts:
    paths:
      - "app/build/outputs/apk/worldAbp/release/app-world-abp-release_SIGNED.apk"
    expire_in: 6 month

  # automated regression tests template using Appium
.template_automation:
  stage: device_tests
  interruptible: true
  retry: 1
  variables:
    GIT_STRATEGY: "none"
    # overridable automation repo; url uses CI_JOB_TOKEN for temporary authorization
    GIT_AUTOMATION_REPO: "https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/eyeo/distpartners/abp_si_automation"
    GIT_AUTOMATION_BRANCH: "main"
    # demo app debug apk
  before_script:
    - test -z ${SAUCE_USERNAME} && echo "echo SAUCE_USERNAME not set. Unable to run tests." && exit 1
    - test -z ${SAUCE_ACCESS_KEY} && echo "echo SAUCE_ACCESS_KEY not set. Unable to run tests." && exit 1
    - curl -u "${SAUCE_USERNAME}:${SAUCE_ACCESS_KEY}" --location --request POST 'https://api.eu-central-1.saucelabs.com/v1/storage/upload'
      --form 'payload=@"$APK_DEBUG_PATH"' --form 'name="app-world-abp-debug.apk"'
    # we are not using submodules, because automation is not a part of repository functionality
  script:
    # its rather a standalone set of scripts
    - git clone $GIT_AUTOMATION_REPO automation
    - cd automation
    - git checkout ${GIT_AUTOMATION_BRANCH:-main}
    # Launch an instance of gradle for each bunch of tags we want to test
    - set +e
    - pids=""
    - |
      for PLATFORM_VERSION in $PLATFORM_VERSIONS
        do export PLATFORM_VERSION
        echo Starting job for version ${PLATFORM_VERSION}
        (./gradlew ${GRADLE_TASK} &> platform_version-${PLATFORM_VERSION}.log ; echo $? > result_${PLATFORM_VERSION}) &
        pids="$pids $!"
      done
    - wait $pids
    # Check for any failures and re-run them
    - |
      for PLATFORM_VERSION in $PLATFORM_VERSIONS
        do if [ -s target/rerun${PLATFORM_VERSION}.txt ] ; then
          echo "Rerunning failed test cases for platform version ${PLATFORM_VERSION}"
          mv target/rerun${PLATFORM_VERSION}.txt target/rerun.txt
          ./gradlew rerunFailed
          echo $? > result_${PLATFORM_VERSION}
          rm -f target/rerun.txt
        fi
      done
    # check the exit codes of all processes were 0
    - |
      for PLATFORM_VERSION in $PLATFORM_VERSIONS
        do test $(cat result_${PLATFORM_VERSION}) = 0
      done
  after_script:
    - cd automation
    - |
      for PLATFORM_VERSION in $PLATFORM_VERSIONS
        do
        echo "**********************************"
        echo "Logs for tests with platform version ${PLATFORM_VERSION}"
        echo "**********************************"
        cat platform_version-${PLATFORM_VERSION}.log
      done
  artifacts:
    expire_in: 6 months
    reports:
      junit: "automation/target/cucumber-reports/*.xml"
    paths:
      - "automation/platform_version-*.log"
      - "automation/result_*"

regression_autojob:
  extends: .template_automation
  variables:
    PLATFORM_VERSIONS: "10"
    GRADLE_TASK: "regression"
  only:
    refs:
      - merge_requests
      - dev
      - web